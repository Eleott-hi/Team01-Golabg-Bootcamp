## Задача: Масштабируемость, Балансировка и Запросы

#### Общий обзор
Вам нужно реализовать два приложения на Go: одно будет клиентом, а другое — экземпляром базы данных. Эти приложения должны поддерживать отказоустойчивость и масштабируемость, обеспечивая репликацию данных и автоматическое переключение на другой экземпляр в случае сбоя.

### Шаг 1: Масштабируемость

#### Основные требования
1. REPL-клиент: Клиентское приложение должно предоставлять интерфейс REPL (Read-Eval-Print Loop) и подключаться к экземпляру базы данных по сети.
2. Репликация и отказоустойчивость:
    - База данных должна поддерживать репликацию данных. Конфигурируемый параметр коэффициент репликации.
    - Клиент должен отправлять запросы на несколько экземпляров базы данных и переключаться на другой экземпляр, если текущий перестал отвечать.
    - При каждом "heartbeat" запросе экземпляр базы данных должен возвращать список всех известных ему экземпляров и текущий коэффициент репликации.

#### Реализация
1. Клиент:
    - Подключение к базе данных по сети (например, HTTP или gRPC).
    - Реализация команды для отправки heartbeat-запросов.
    - Автоматическое переключение на другой экземпляр в случае сбоя текущего.
2. Экземпляр базы данных:
    - Обработка команд (GET, SET, DELETE).
    - Реализация механизма heartbeat для проверки состояния экземпляров.
    - Хранение списка известных экземпляров и их адресов.
    - Проверка коэффициента репликации при подключении нового экземпляра.

### Шаг 2: Балансировка и Запросы

#### Основные требования
1. Операции с данными:
    - Поддержка операций GET, SET и DELETE.
    - Использование UUID4 для ключей.
    - Обеспечение консистентности данных: немедленная консистентность для новых записей (read-after-write) и eventual consistency для обновлений и удалений.
2. Балансировка нагрузки:
    - Клиент должен уметь рассчитывать, на какие экземпляры должны сохраняться данные в зависимости от коэффициента репликации.
    - Если текущий экземпляр базы данных не отвечает, клиент должен повторить запрос к другому экземпляру.

#### Реализация
1. Клиент:
    - Реализация команд SET, GET и DELETE.
    - Проверка правильности формата UUID4 для ключей.
    - Расчет списка экземпляров для хранения данных с учетом коэффициента репликации.
2. Экземпляр базы данных:
    - Хранение и управление данными (операции GET, SET, DELETE).
    - Обеспечение консистентности данных.
    - Обработка запросов от клиента и других экземпляров.

### Шаг 3: Лидер и Фолловеры

#### Основные требования
1. Лидер и Фолловеры:
    - Клиент взаимодействует только с лидером.
    - Лидер распределяет реплики данных.
    - Каждый экземпляр отправляет heartbeats всем другим экземплярам.
    - В случае сбоя лидера фолловеры выбирают нового лидера.
2. Избирательный процесс:
    - Если лидер не отвечает, фолловеры выбирают нового лидера на основе упорядоченного списка экземпляров.

#### Реализация
1. Клиент:
    - Подключение к лидеру и повторный поиск лидера в случае его сбоя.
2. Экземпляр базы данных:
    - Определение ролей (лидер или фолловер).
    - Обработка heartbeats и выбор нового лидера при необходимости.

### Дополнительное задание: Консенсус

#### Основные требования
1. Реализация консенсуса:
    - Использование протоколов, таких как Raft или Paxos, для обеспечения согласованности данных между экземплярами.

#### Реализация
1. Выбор протокола:
    - Реализация существующей библиотеки или написание собственного минимального решения для протокола консенсуса.

### Пример кода

Этот пример представляет основу для реализации требуемого функционала. Вам нужно будет расширить эти приложения, чтобы они поддерживали всю указанную функциональность, включая обработку heartbeats, репликацию данных и выбор лидера.

#### Пример кода для клиента (CLI)
```go
package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
    "strings"
)

func main() {
    reader := bufio.NewReader(os.Stdin)
    fmt.Println("Warehouse CLI")
    fmt.Println("---------------------")

    for {
        fmt.Print("> ")
        text, _ := reader.ReadString('\n')
        text = strings.TrimSpace(text)
        
        if len(text) > 0 {
            fmt.Println("Command:", text)
            // Отправка команды на сервер
            handleCommand(text)
        }
    }
}

func handleCommand(command string) {
    conn, err := net.Dial("tcp", "127.0.0.1:8765")
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }
    defer conn.Close()

    fmt.Fprintf(conn, command+"\n")
    response, _ := bufio.NewReader(conn).ReadString('\n')
    fmt.Println("Response:", response)
}
```

#### Пример кода для экземпляра базы данных
```go
package main

import (
    "bufio"
    "fmt"
    "net"
    "strings"
)

var dataStore = make(map[string]string)

func main() {
    listener, err := net.Listen("tcp", "127.0.0.1:8765")
    if err != nil {
        fmt.Println("Error listening:", err)
        return
    }
    defer listener.Close()

    fmt.Println("Database instance running on 127.0.0.1:8765")

    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("Error accepting:", err)
            return
        }
        go handleRequest(conn)
    }
}

func handleRequest(conn net.Conn) {
    defer conn.Close()
    request, err := bufio.NewReader(conn).ReadString('\n')
    if err != nil {
        fmt.Println("Error reading:", err)
        return
    }
    command := strings.TrimSpace(request)
    response := executeCommand(command)
    conn.Write([]byte(response + "\n"))
}

func executeCommand(command string) string {
    parts := strings.Fields(command)
    if len(parts) < 2 {
        return "Error: invalid command"
    }

    action := parts[0]
    key := parts[1]

    switch action {
    case "SET":
        if len(parts) < 3 {
            return "Error: invalid command"
        }
        value := parts[2]
        dataStore[key] = value
        return "Created"
    case "GET":
        if value, exists := dataStore[key]; exists {
            return value
        } else {
            return "Not found"
        }
    case "DELETE":
        delete(dataStore, key)
        return "Deleted"
    default:
        return "Error: unknown command"
    }
}
```
